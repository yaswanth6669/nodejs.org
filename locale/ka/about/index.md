---
layout: about.hbs
title: პროექტის შესახებ
trademark: სავაჭრო ნიშანი
---

# Node.js®-ის შესახებ

როგორც ასინქრონული, მოვლენებზე დაფუძნებული JavaScript-ის გამშვები გარემო, Node.js შექმნილია
მასშტაბირებადი (გაფართოებადი) ქსელური აპლიკაციების შესაქმნელად. ქვემოთ მოცემულ ("hello world") მაგალითში,
ერთდროულად მრავალი კავშირის დამუშავებაა შესაძლებელი. თითოეული კავშირისთვის მოხდება (callback) ფუნქციის
გამოძახება, მაგრამ თუ გასაკეთებელი არაფერია, Node.js დარჩება უმოქმედოდ (დაიძინებს).

```javascript
const http = require('http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

ეს მიდგომა განსხვავდება დღესდღეობით უფრო გავრცელებული პარალელიზმის მოდელისგან, რომელშიც გამოიყენება OS-ნაკადები (threads).
ნაკადზე დაფუძნებული მიდგომა შედარებით არაეფექტურია და ძალიან
რთულია გამოსაყენებლად. უფრო მეტიც, Node.js-ის მომხმარებლებს არ უწევთ, იდარდონ
პროცესების ბლოკირებაზე, რადგან აქ არ არსებობს ბლოკირება.
Node.js-ის თითქმის არც ერთი ფუნქცია არ ახორციელებს უშუალოდ შეტანა/გამოტანას, ამიტომ პროცესი არასოდეს იბლოკება გარდა იმ შემთხვევისა, როცა შეტანა/გამოტანა ხორციელდება
Node.js-ის სტანდარტული ბიბლიოთეკის სინქრონული მეთოდების გამოყენებით. ყოველივე ამის გამო, Node.js-ის გამოყენება მასშტაბირებადი სისტემების შესაქმნელად
ძალიან გონივრულია.

თუ თქვენთვის ზემოთ მოხსენიებული ტერმინებიდან რომელიმე გაუგებარია, იხილეთ სრული სტატია:
[ბლოკირება vs არა-ბლოკირება][].

---

Node.js დიზაინით მსგავსია, და იმყოფება გავლენის ქვეშ ისეთი სისტემებისა, როგორებიცაა:
[Event Machine][] Ruby-ში და [Twisted][] Python-ში. თუმცა, მასში (Node.js-ში) მოვლენათა მოდელი ბევრად უფრო
ფართოდ გამოიყენება. იგი [მოვლენათა ციკლს][] წარმოგვიდგენს როგორც გამშვები გარემოს კონსტრუქციას, ნაცვლად იმისა, რომ წარმოგვიდგინოს ბიბლიოთეკის სახით. სხვა სისტემებში,
მოვლენათა ციკლის დასაწყებად ყოველთვის გვაქვს დამბლოკველი გამოძახება.
როგორც წესი, ქცევა განისაზღვრება ფუნქციების მეშვეობით სკრიპტის დასაწყისში, ბოლოს კი — დამბლოკველი გამოძახების მეშვეობით, როგორიცაა `EventMachine::run()` — სერვერი ეშვება.
Node.js-ში მოვლენათა ციკლის დასაწყებად მსგავსი გამოძახება არ გვაქვს: იგი (შემავალი) სკრიპტის გაშვების შემდეგ ავტომატურად შედის მოვლენათა ციკლში.
როდესაც განსახორციელებელი ფუნქციები (callbacks) აღარ დარჩება, Node.js გამოდის მოვლენათა ციკლიდან. ეს ქცევა
წააგავს JavaScript-ის ქცევას ბრაუზერში: მოვლენათა ციკლი დამალულია მომხმარებლისაგან.

Node.js-ში განსაკუთრებული ადგილი უკავია HTTP-ს, რომელიც შექმნილია სტრიმინგისა და დაბალი
შეყოვნების გათვალისწინებით. ეს Node.js-ს აქცევს იდეალურ საფუძვლად
ვებ-ბიბლიოთეკის ან framework-ის დასაშენებლად.

ის ფაქტი, რომ Node.js შექმნილია ნაკადების (threads) გარეშე, არ ნიშნავს იმას, რომ არ შეგიძლიათ,
თქვენს გარემოში მრავალი ბირთვით ისარგებლოთ. შვილობილი პროცესების წარმოქმნა შეგიძლიათ
[`child_process.fork()`][] API-ის გამოყენებით.
ამავე ინტერფეისის საფუძველზეა აგებული [`cluster`][] მოდული,
რომელიც საშუალებას გაძლევთ, დაყოთ სოკეტები პროცესებს შორის,
რათა დატვირთვა გადანაწილდეს ბირთვებზე.

[ბლოკირება vs არა-ბლოკირება]: /en/docs/guides/blocking-vs-non-blocking/
[`child_process.fork()`]: https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options
[`cluster`]: https://nodejs.org/api/cluster.html
[მოვლენათა ციკლს]: /en/docs/guides/event-loop-timers-and-nexttick/
[Event Machine]: https://github.com/eventmachine/eventmachine
[Twisted]: https://twistedmatrix.com/trac/
